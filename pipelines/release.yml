# Release Pipeline for LCDPossible
# Triggers on push to main branch
# Builds artifacts for all platforms and creates GitHub release

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - '*.md'
      - 'docs/**'

pr: none

variables:
  - group: kv-devpossible-secrets
  - name: DOTNET_NOLOGO
    value: 'true'
  - name: DOTNET_SKIP_FIRST_TIME_EXPERIENCE
    value: 'true'
  - name: DOTNET_CLI_TELEMETRY_OPTOUT
    value: 'true'
  - name: NUGET_PACKAGES
    value: $(Pipeline.Workspace)/.nuget/packages
  - name: dotnetVersion
    value: '10.0.x'
  - name: githubRepo
    value: 'DevPossible/lcd-possible'

stages:
  # Stage 1: Check if CI already passed for this commit
  - stage: CheckCI
    displayName: Check CI Status
    jobs:
      - job: CheckCIStatus
        displayName: Check for passing CI build
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - bash: |
              set -e
              echo "Checking for passing CI build for commit $(Build.SourceVersion)..."

              AUTH_HEADER="Authorization: Bearer $SYSTEM_ACCESSTOKEN"
              BASE_URL="$(System.CollectionUri)$(System.TeamProject)/_apis/build"

              # Query for successful CI builds on this commit (Definition ID 6 = LCDPossible-CI)
              BUILDS=$(curl -s -H "$AUTH_HEADER" "$BASE_URL/builds?definitions=6&statusFilter=completed&resultFilter=succeeded&api-version=7.1")
              MATCHING_BUILD=$(echo "$BUILDS" | jq -r ".value[] | select(.sourceVersion == \"$(Build.SourceVersion)\") | .id" | head -1)

              if [ -n "$MATCHING_BUILD" ]; then
                echo "Found passing CI build: $MATCHING_BUILD"
                echo "##vso[task.setvariable variable=needsCI;isOutput=true]false"
              else
                echo "No passing CI build found. Will run CI tests inline."
                echo "##vso[task.setvariable variable=needsCI;isOutput=true]true"
              fi
            displayName: Check for passing CI build
            name: ciCheck
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

  # Stage 2: Run CI tests inline if no passing CI build exists
  - stage: CI
    displayName: Run CI Tests
    dependsOn: CheckCI
    condition: eq(stageDependencies.CheckCI.CheckCIStatus.outputs['ciCheck.needsCI'], 'true')
    jobs:
      - job: BuildAndTest
        displayName: Build & Test
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - script: |
              sudo apt-get update
              sudo apt-get install -y vlc libvlc-dev fonts-dejavu-core
            displayName: Install Linux dependencies

          - task: UseDotNet@2
            displayName: Setup .NET
            inputs:
              packageType: 'sdk'
              version: $(dotnetVersion)
              includePreviewVersions: true

          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | src/**/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: $(NUGET_PACKAGES)

          - script: dotnet restore src/LCDPossible.sln
            displayName: Restore dependencies

          - script: dotnet build src/LCDPossible.sln --configuration Release --no-restore
            displayName: Build

          # Quick tests only - unit tests, skip functional tests (full CI runs on develop)
          - script: dotnet test tests/LCDPossible.Core.Tests/LCDPossible.Core.Tests.csproj --configuration Release --no-build --verbosity normal
            displayName: Test (unit tests only)

          - script: dotnet format src/LCDPossible.sln --verify-no-changes --verbosity diagnostic
            displayName: Check code formatting

  # Stage 3: Calculate version
  - stage: Version
    displayName: Calculate Version
    dependsOn:
      - CheckCI
      - CI
    # Run if CheckCI succeeded AND CI either succeeded or was skipped (not failed)
    condition: and(succeeded('CheckCI'), not(failed('CI')))
    jobs:
      - job: CalculateVersion
        displayName: Determine Release Version
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - bash: |
              # Check if HEAD already has a tag
              EXISTING_TAG=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)

              if [ -n "$EXISTING_TAG" ]; then
                VERSION="${EXISTING_TAG#v}"
                echo "Found existing tag: $EXISTING_TAG"
                echo "##vso[task.setvariable variable=version;isOutput=true]$VERSION"
                echo "##vso[task.setvariable variable=tagExists;isOutput=true]true"
                echo "##vso[task.setvariable variable=shouldRelease;isOutput=true]true"
                exit 0
              fi

              echo "No existing tag on HEAD, calculating version from commits..."
              echo "##vso[task.setvariable variable=tagExists;isOutput=true]false"

              # Calculate version using conventional commits
              chmod +x ./scripts/get-version.sh
              VERSION=$(./scripts/get-version.sh)
              echo "Calculated version: $VERSION"

              # Check if this version tag already exists
              if git rev-parse "v$VERSION" >/dev/null 2>&1; then
                echo "Tag v$VERSION already exists, bumping patch..."
                IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
                while git rev-parse "v$MAJOR.$MINOR.$PATCH" >/dev/null 2>&1; do
                  PATCH=$((PATCH + 1))
                done
                VERSION="$MAJOR.$MINOR.$PATCH"
                echo "Next available version: $VERSION"
              fi

              echo "##vso[task.setvariable variable=version;isOutput=true]$VERSION"
              echo "##vso[task.setvariable variable=shouldRelease;isOutput=true]true"
              echo "Version: $VERSION"
            displayName: Calculate version
            name: versionStep

          - bash: |
              VERSION="$(versionStep.version)"
              LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo "")

              echo "Last tag: ${LAST_TAG:-(none)}"

              if [ -n "$LAST_TAG" ]; then
                COMMITS=$(git log "$LAST_TAG..HEAD" --pretty=format:"- %s" --reverse)
                COMPARE_URL="https://github.com/$(githubRepo)/compare/${LAST_TAG}...v${VERSION}"
              else
                COMMITS=$(git log --pretty=format:"- %s" --reverse | head -50)
                COMPARE_URL="https://github.com/$(githubRepo)/commits/v${VERSION}"
              fi

              cat > $(Build.ArtifactStagingDirectory)/changelog.md << EOF
              ## What's Changed

              $COMMITS

              **Full Changelog**: $COMPARE_URL
              EOF

              echo "Generated changelog:"
              cat $(Build.ArtifactStagingDirectory)/changelog.md
            displayName: Generate changelog

          - publish: $(Build.ArtifactStagingDirectory)/changelog.md
            artifact: changelog
            displayName: Publish changelog

  - stage: Build
    displayName: Build Artifacts
    dependsOn: Version
    condition: succeeded('Version')
    variables:
      version: $[ stageDependencies.Version.CalculateVersion.outputs['versionStep.version'] ]
    jobs:
      - job: BuildWindows
        displayName: Build (win-x64)
        pool:
          vmImage: 'windows-latest'
        steps:
          - template: templates/build-job.yml
            parameters:
              runtime: 'win-x64'
              version: $(version)
              archiveType: 'zip'
              skipTests: true

      - job: BuildLinuxX64
        displayName: Build (linux-x64)
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - template: templates/build-job.yml
            parameters:
              runtime: 'linux-x64'
              version: $(version)
              archiveType: 'tar'
              skipTests: true

      - job: BuildLinuxArm64
        displayName: Build (linux-arm64)
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - template: templates/build-job.yml
            parameters:
              runtime: 'linux-arm64'
              version: $(version)
              archiveType: 'tar'
              skipTests: true

      - job: BuildMacOSX64
        displayName: Build (osx-x64)
        pool:
          vmImage: 'macos-latest'
        steps:
          - template: templates/build-job.yml
            parameters:
              runtime: 'osx-x64'
              version: $(version)
              archiveType: 'tar'
              skipTests: true

      - job: BuildMacOSArm64
        displayName: Build (osx-arm64)
        pool:
          vmImage: 'macos-latest'
        steps:
          - template: templates/build-job.yml
            parameters:
              runtime: 'osx-arm64'
              version: $(version)
              archiveType: 'tar'
              skipTests: true

  - stage: Release
    displayName: Create Release
    dependsOn:
      - Version
      - Build
    condition: and(succeeded('Version'), succeeded('Build'))
    variables:
      version: $[ stageDependencies.Version.CalculateVersion.outputs['versionStep.version'] ]
      tagExists: $[ stageDependencies.Version.CalculateVersion.outputs['versionStep.tagExists'] ]
    jobs:
      - job: CreateGitHubRelease
        displayName: Create GitHub Release
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true

          - download: current
            displayName: Download all artifacts

          - bash: |
              echo "Creating tag v$(version) if it doesn't exist..."
              if [ "$(tagExists)" != "true" ]; then
                git config user.name "Azure Pipelines"
                git config user.email "azuredevops@devpossible.com"
                git tag -a "v$(version)" -m "Release v$(version)"
                git push origin "v$(version)"
                echo "Tag v$(version) created and pushed"
              else
                echo "Tag already exists, skipping tag creation"
              fi
            displayName: Create git tag
            condition: ne(variables['tagExists'], 'true')

          - bash: |
              echo "Artifacts downloaded:"
              ls -R $(Pipeline.Workspace)
            displayName: List artifacts

          - task: GitHubRelease@1
            displayName: Create GitHub Release
            inputs:
              gitHubConnection: 'github.com_DevPossible'
              repositoryName: '$(githubRepo)'
              action: 'create'
              target: '$(Build.SourceVersion)'
              tagSource: 'userSpecifiedTag'
              tag: 'v$(version)'
              title: 'LCDPossible v$(version)'
              releaseNotesFilePath: '$(Pipeline.Workspace)/changelog/changelog.md'
              assets: |
                $(Pipeline.Workspace)/artifact-win-x64/*.zip
                $(Pipeline.Workspace)/artifact-linux-x64/*.tar.gz
                $(Pipeline.Workspace)/artifact-linux-arm64/*.tar.gz
                $(Pipeline.Workspace)/artifact-osx-x64/*.tar.gz
                $(Pipeline.Workspace)/artifact-osx-arm64/*.tar.gz
              isDraft: false
              isPreRelease: false
              addChangeLog: false
